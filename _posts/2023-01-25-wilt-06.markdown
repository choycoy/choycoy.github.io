---
title: "What I learnt today 25/01/23"
tags:  
  - WILT
  - Python
---
ðŸ’¡ This post introduces what I learnt today 25/01/23.
{: .notice--warning}

# Numpy (How can we represent the numerical operation in code?: use proper package)
- Numerical Python, a library for the Python programming language
<br>
- adding support for large, multi-dimensional `arrays` and `matrices`, along with a large collection of high-level mathematical functions to operate on these arrays
<br>
- more faster than general list and **efficient memory**
<br>
- supports the process of data array without iteration
<br>
- provides various function related to `linear algebra`
<br>
- can integrate with the language such as C, C++ and Fortran

## 1. ndarray
```
import numpy as np
```
generally call numpy using alias `np`

- Array Creation

```
test_array = np.array([1,4,5,8], float)
print(test_array)
type(test_array[3])
```

```
numpy.float64
```

1) create an array using `np.array` function -> `ndarray`
<br>
<br>
2) numpy can have `one data type` in the array
<br>
<br>
3) big difference between list and array, **dynamic typing not supported**
<br>
<br>
4) create an array using Array of C
<br>
<br>
![numpyarray](https://user-images.githubusercontent.com/40441643/214832896-a92e6548-b19b-4817-8d4c-33163761f19f.PNG)
<br>
<br>
![ndarraydatastructure](https://user-images.githubusercontent.com/40441643/214834041-f595e70c-c837-4eb3-9dd3-3068115742f9.PNG)
<br>
```
test_array = np.array([1,4,5,"8"], float) # even though input was string type
print(test_array)           # array([1., 4., 5., 8.])
print(type(test_array[3]))  # numpy.float64 : the output was converted to float automatically
print(test_array.dtype)     # dtype('float64')
print(test_array.shape)     # (4,)
```
- `shape`: returns the `dimension` composition of an object in a numpy array
- `dtype`: returns the `data type` of numpy array
- Array shape(vector)
<br>
information on the size and `shape` of Array(vector, matrix, tensor)
<br>
`(4,)` -> shape of ndarray **(type: tuple)**
<br>
![ndshape](https://user-images.githubusercontent.com/40441643/214887824-c31c4577-f1bb-4785-984f-d2ae8de8f6bf.PNG)
<br>
<br>
![arrayshape](https://user-images.githubusercontent.com/40441643/214888315-1092305a-4de5-46c4-ad69-e189951fce31.PNG)
<br>
<br>
- Array shape - `ndim` & `size`
<br>
`ndim`: number of dimension
<br>
`size`: number of data
<br>
![ndim](https://user-images.githubusercontent.com/40441643/214889489-ff6183b3-7613-4bbb-8096-efadc669ea9b.PNG)
- Array dtype
<br>
`data type` of single element of Ndarray
<br>
the amount of **memory occupied** by each element is determined

```
np.array([1, 2, 3], [4.5, 5, 6]], dtype = int)
```

```
array([1, 2, 3],
  [4, 5, 6])
```

```
np.array([1, 2, 3], [4.5, "5", "6"]], dtype = np.float32)
```

```
array([[1. , 2. , 3.], [4.5, 5. , 6.  ]], dtype = float32)
```
<br>
![c_compatiable](https://user-images.githubusercontent.com/40441643/214893859-3a652e5c-1860-4fde-9871-3bae1fc7a4e2.PNG)
<br>
<br>
`nbytes`: return the **memory size** of ndarray object
```
np.array([1, 2, 3], [4.5, "5", "6"]], dtype = np.float32).nbytes
```
```
24        32 bits = 4 bytes -> 6*4 bytes
```
```
np.array([1, 2, 3], [4.5, "5", "6"]], dtype = np.int8).nbytes
```
```
6       8 bits = 1 byte -> 6*1 bytes
```
```
np.array([1, 2, 3], [4.5, "5", "6"]], dtype = np.float64).nbytes
```
```
48      64 bits = 8 bytes -> 6 *8 bytes
```

## 2. Handling Shape
- `reshape`
<br>
change the size of Array's shape(the number of elements is the same)

![reshape](https://user-images.githubusercontent.com/40441643/215025806-eecedf5d-e7d4-4f76-bed0-9194db2ab93b.PNG)
<br>

```
test_matrix = [[1,2,3,4], [1,2,5,8]]
np.array(test_matrix).shape # (2,4)

np.array(test_matrix).reshape(8,) # array([1,2,3,4,1,2,5,8])

np.array(test_matrix).reshape(8,).shape # (8, )
```
If the size of array is same, it can be changed to be multi-dimensional.
```
np.array(test_matrix).reshape(2,4).shape  # (2,4)
np.array(test_matrix).reshape(-1,2).shape # (4,2)
np.array(test_matrox).reshape(2,2,2) # array([[1,2], [3,4]], [[1,2], [5,8]])
np.array(test_matrix).reshape(2,2,2).shape # (2,2,2)
```
`-1`: the number of row is determined based on the **size**

- `flatten`
<br>
convert **multi-dimensional array** to **one dimensional array**.

![flatten](https://user-images.githubusercontent.com/40441643/215026656-e7ee7d86-8e05-44d9-ac58-84d7c274a217.PNG)
<br>
```
test_matrix =[[[1,2,3,4], [1,2,5,8]], [[1,2,3,4], [1,2,5,8]]]
np.array(test_matrix).flatten()
```

```
array([1,2,3,4,1,2,5,8,1,2,3,4,1,2,5,8])
```

## 3. Indexing & Slicing
- Indexing
<br>

```
a = np.array([[1,2,3], [4.5, 5, 6]], int)
print(a)
print(a[0,0]) # two dimensional array representation 1
print(a[0][0]) # two dimensional array representation 2

a[0,0] = 12 # assign 12 in matrix 0,0
a[0][0] = 5 # assign 12 in matrix 0,0
```
Unlikely the list, the representation such as `[0,0]` is provided in two dimensional array.
<br>
In case of matrix, the front means `row` and the back is `column`.

```
test_example = np.array([[1, 2, 3], [4.5, 5, 6]], int)
test_example  # array([[1, 2, 3], [4, 5, 6]])
test_example[0][0] # 1
test_example[0, 0] # 1
test_example [0, 0] = 12 # assign 12 in matrix 0,0
test_example # array([[12, 2, 3], [ 4, 5, 6]])
test_example[0][0] = 5 # assign 5 in matrix 0,0
test_example[0,0] # 5
```

- Slicing
<br>

```
a = np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]], int)
a[:,2:] # more than second column of the entire row
a[1,1:3]  # first column and second column of first row
a[1:3]  # the entire of first row and second row
```
Unlikely the list, we can **slice with dividing the column and row**.
<br>
It is useful to extract **subset of matrix**.
<br>
![slicing2](https://user-images.githubusercontent.com/40441643/215054124-1e0d6881-fadd-4b4d-89ba-8a0f8378252d.PNG)

## 4. Creation Function
- `Arrange`
<br>
A command that creates a list of values by specifying a range of arrays.
```
np.arrange(30) # extract the integer from 0 to 29, arra([0, 1, ..., 29])
np.arrange(0, 5, 0.5) # 0 is the start point, 5 is the end point, and 0.5 is step size, array([0., 0.5, 1,....4, 4.5])
np.arrange(30).reshape(5,6)
```
