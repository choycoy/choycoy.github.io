---
title: "What I learnt today 25/01/23"
tags:  
  - WILT
  - Python
---
ðŸ’¡ This post introduces what I learnt today 25/01/23.
{: .notice--warning}

# Numpy (How can we represent the numerical operation in code?: use proper package)
- Numerical Python, a library for the Python programming language
<br>
- adding support for large, multi-dimensional `arrays` and `matrices`, along with a large collection of high-level mathematical functions to operate on these arrays
<br>
- more faster than general list and **efficient memory**
<br>
- supports the process of data array without iteration
<br>
- provides various function related to `linear algebra`
<br>
- can integrate with the language such as C, C++ and Fortran

## 1. ndarray
```
import numpy as np
```
generally call numpy using alias `np`

- Array Creation

```
test_array = np.array([1,4,5,8], float)
print(test_array)
type(test_array[3])
```

```
numpy.float64
```

1) create an array using `np.array` function -> `ndarray`
<br>
<br>
2) numpy can have `one data type` in the array
<br>
<br>
3) big difference between list and array, **dynamic typing not supported**
<br>
<br>
4) create an array using Array of C
<br>
<br>
![numpyarray](https://user-images.githubusercontent.com/40441643/214832896-a92e6548-b19b-4817-8d4c-33163761f19f.PNG)
<br>
<br>
![ndarraydatastructure](https://user-images.githubusercontent.com/40441643/214834041-f595e70c-c837-4eb3-9dd3-3068115742f9.PNG)
<br>
```
test_array = np.array([1,4,5,"8"], float) # even though input was string type
print(test_array)           # array([1., 4., 5., 8.])
print(type(test_array[3]))  # numpy.float64 : the output was converted to float automatically
print(test_array.dtype)     # dtype('float64')
print(test_array.shape)     # (4,)
```
- `shape`: returns the `dimension` composition of an object in a numpy array
- `dtype`: returns the `data type` of numpy array
- Array shape(vector)
<br>
information on the size and `shape` of Array(vector, matrix, tensor)
<br>
`(4,)` -> shape of ndarray **(type: tuple)**
<br>
![ndshape](https://user-images.githubusercontent.com/40441643/214887824-c31c4577-f1bb-4785-984f-d2ae8de8f6bf.PNG)
<br>
<br>
![arrayshape](https://user-images.githubusercontent.com/40441643/214888315-1092305a-4de5-46c4-ad69-e189951fce31.PNG)
<br>
<br>
- Array shape - `ndim` & `size`
<br>
`ndim`: number of dimension
<br>
`size`: number of data
<br>
![ndim](https://user-images.githubusercontent.com/40441643/214889489-ff6183b3-7613-4bbb-8096-efadc669ea9b.PNG)
- Array dtype
<br>
`data type` of single element of Ndarray
<br>
the amount of **memory occupied** by each element is determined

```
np.array([1, 2, 3], [4.5, 5, 6]], dtype = int)
```

```
array([1, 2, 3],
  [4, 5, 6])
```

```
np.array([1, 2, 3], [4.5, "5", "6"]], dtype = np.float32)
```

```
array([[1. , 2. , 3.], [4.5, 5. , 6.  ]], dtype = float32)
```
<br>
![c_compatiable](https://user-images.githubusercontent.com/40441643/214893859-3a652e5c-1860-4fde-9871-3bae1fc7a4e2.PNG)
<br>
<br>
`nbytes`: return the **memory size** of ndarray object
```
np.array([1, 2, 3], [4.5, "5", "6"]], dtype = np.float32).nbytes
```
```
24        32 bits = 4 bytes -> 6*4 bytes
```
```
np.array([1, 2, 3], [4.5, "5", "6"]], dtype = np.int8).nbytes
```
```
6       8 bits = 1 byte -> 6*1 bytes
```
```
np.array([1, 2, 3], [4.5, "5", "6"]], dtype = np.float64).nbytes
```
```
48      64 bits = 8 bytes -> 6 *8 bytes
```

## 2. Handling Shape
- `reshape`
<br>
change the size of Array's shape(the number of elements is the same)

![reshape](https://user-images.githubusercontent.com/40441643/215025806-eecedf5d-e7d4-4f76-bed0-9194db2ab93b.PNG)
<br>

```
test_matrix = [[1,2,3,4], [1,2,5,8]]
np.array(test_matrix).shape # (2,4)

np.array(test_matrix).reshape(8,) # array([1,2,3,4,1,2,5,8])

np.array(test_matrix).reshape(8,).shape # (8, )
```
If the size of array is same, it can be changed to be multi-dimensional.
```
np.array(test_matrix).reshape(2,4).shape  # (2,4)
np.array(test_matrix).reshape(-1,2).shape # (4,2)
np.array(test_matrox).reshape(2,2,2) # array([[1,2], [3,4]], [[1,2], [5,8]])
np.array(test_matrix).reshape(2,2,2).shape # (2,2,2)
```
`-1`: the number of row is determined based on the **size**

- `flatten`
<br>
convert **multi-dimensional array** to **one dimensional array**.

![flatten](https://user-images.githubusercontent.com/40441643/215026656-e7ee7d86-8e05-44d9-ac58-84d7c274a217.PNG)
<br>
```
test_matrix =[[[1,2,3,4], [1,2,5,8]], [[1,2,3,4], [1,2,5,8]]]
np.array(test_matrix).flatten()
```

```
array([1,2,3,4,1,2,5,8,1,2,3,4,1,2,5,8])
```

## 3. Indexing & Slicing
- Indexing
<br>

```
a = np.array([[1,2,3], [4.5, 5, 6]], int)
print(a)
print(a[0,0]) # two dimensional array representation 1
print(a[0][0]) # two dimensional array representation 2

a[0,0] = 12 # assign 12 in matrix 0,0
a[0][0] = 5 # assign 12 in matrix 0,0
```
Unlikely the list, the representation such as `[0,0]` is provided in two dimensional array.
<br>
In case of matrix, the front means `row` and the back is `column`.

```
test_example = np.array([[1, 2, 3], [4.5, 5, 6]], int)
test_example  # array([[1, 2, 3], [4, 5, 6]])
test_example[0][0] # 1
test_example[0, 0] # 1
test_example [0, 0] = 12 # assign 12 in matrix 0,0
test_example # array([[12, 2, 3], [ 4, 5, 6]])
test_example[0][0] = 5 # assign 5 in matrix 0,0
test_example[0,0] # 5
```

- Slicing
<br>

```
a = np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]], int)
a[:,2:] # more than second column of the entire row
a[1,1:3]  # first column and second column of first row
a[1:3]  # the entire of first row and second row
```
Unlikely the list, we can **slice with dividing the column and row**.
<br>
It is useful to extract **subset of matrix**.
<br>
![slicing2](https://user-images.githubusercontent.com/40441643/215054124-1e0d6881-fadd-4b4d-89ba-8a0f8378252d.PNG)

## 4. Creation Function
- `Arrange`
<br>
A command that creates a list of values by **specifying a range** of arrays.
```
np.arrange(30) # extract the integer from 0 to 29, arra([0, 1, ..., 29])
np.arrange(0, 5, 0.5) # 0 is the start point, 5 is the end point, and 0.5 is step size, array([0., 0.5, 1,....4, 4.5])
np.arrange(30).reshape(5,6)
```
- `ones`, `zeros` and `empty`
<br>
(1) `zeros`: create `ndarray` with full 0s, `np.zeros(shape, dtype, order)`
<br>
```
np.zeros(shape = (10, ), dtype = np.int8) # 10, create zero vector
```
```
array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], dtype=int8)
```
```
np.zeros((2, 5)) # 2 by 5, create zero matrix
```
```
array([[0., 0., 0., 0., 0],
       [0., 0., 0., 0., o]])
```
(2) `ones`: create `ndarray` with full 1s, `np.ones(shape, dtype, order)`
```
np.ones(shape= (10,), dtype = np.int8)
```
```
array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1], dtype=int8)
```
(3)`empty`: crate `empty ndarray` given shape, can initialise memory
<br>
```
np.empty(shape=(10,), dtype=np.int8)
```
```
array([ 0,  0,  0,  0,  0,  0,  0, 64, -72, 105], dtype = int8)
```
```
np.empty((3, 5))
```
![empty](https://user-images.githubusercontent.com/40441643/215316225-6bdaf013-cf83-4a5e-b8f6-f7138769b8fc.PNG)
<br>
- `something_like`: return **one, zero or empty array** as much as the shape of original ndarray, e.g. one_like
<br>
```
test_matrix = np.shape(30).reshape(5,6)
np.ones_like(test_matrix)
```
![somethinglike](https://user-images.githubusercontent.com/40441643/215316811-361d2cc2-92dd-48a3-b89d-ebf3965533ab.PNG)
- `identity`: create identity matrix, number of rows = n
<br>
```
np.identity(n=3, dtype = np.int8)
```
```
array([1, 0, 0],
      [0, 1, 0],
      [0, 0, 1], dtype = int8)
```
```
np.identity(5)
```
![identity](https://user-images.githubusercontent.com/40441643/215317399-ed27d591-2ead-483d-8e62-eaf1538377a0.PNG)
- `eye`: the diagonal of array is `1`, start index: k can be changed
<br>
```
np.eye(N=3, M=5, dtype = np.int8)
```
```
array([[1, 0, 0, 0, 0],
      [0, 1, 0, 0, 0],
      [0, 0, 1, 0, 0]], dtype=int8)
```
```
np.eye(3)
```
```
array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]])
```
```
np.eye(3, 4, k=2)
```
```
array([[0., 0., 1., 0., 0.],
       [0., 0., 0., 1., 0.],
       [0., 0., 0., 0., 1.])
```
- `diag`: extract the value of diagonal matrix
<br>
![diag](https://user-images.githubusercontent.com/40441643/215318369-cf98fe36-5a66-4a48-9cfc-349f70e1be2e.PNG)

- `random sampling`: create the array with **sampling** by data distribution
```
np.random.uniform(0, 1, 10).reshape(2,5)  # uniform distribution
```
![uniform](https://user-images.githubusercontent.com/40441643/215318621-d4d3a84e-d0c1-4821-9d36-35ac748455ec.PNG)
<br>
```
np.random.normal(0, 1, 10).reshape(2,5)   # normal distribution
```
![normal](https://user-images.githubusercontent.com/40441643/215318608-6ff368c2-65ef-4536-a96e-339c72aa30e4.PNG)
